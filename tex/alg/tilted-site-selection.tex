\begin{algorithm}[H]
\caption{Tilted algorithm site selection $\colorK(\colorT)$.\\ \footnotesize Supplementary Algorithm \ref{alg:tilted-time-lookup} gives tilted algorithm site lookup $\colorL(\colorT)$. Supplementary Listings \cref{lst:tilted_site_selection.py,lst:tilted_time_lookup.py} provide reference Python code.}
\label{alg:tilted-site-selection}
\begin{minipage}{0.53\textwidth}
    \hspace*{\algorithmicindent} \textbf{Input:} $\colorS \in \{2^{\mathbb{N}}\},\;\; \colorT \in [0 \twodots 2^{\colorS - 1})$ \textcolor{teal}{\small//Buffer size, current logical time}\\
    \hspace*{\algorithmicindent} \textbf{Output:} $\colork \in [0 \twodots \colorS - 1)$ \textcolor{teal}{\small//Selected site in buffer}
    \begin{algorithmic}[1]
        \State $\texttt{uint} ~ ~ \colors \gets \Call{BitLength}{\colorS} - 1$ \textcolor{teal}{\small//Log buffer size}
        \State $\texttt{uint} ~ ~ \colort \gets \max(0,\;\; \Call{BitLength}{\colorT} - \colors)$ \textcolor{teal}{\small//Current epoch}
        \State $\texttt{uint} ~ ~ \colorh \gets \Call{CountTrailingZeros}{\colorT + 1}$ \textcolor{teal}{\small//Current \hv{}}
        \State $\texttt{uint} ~ ~ i \gets \Call{RightShift}{\colorT, \;\; \colorh + 1}$ \textcolor{teal}{\small//Num of \hv{} $\colorh$ seen}
        \State $\texttt{bool} ~ ~ \epsilon_{\colortau} \gets \Call{BitFloorSafe}{2\colort} \;\; > \;\; \colort + \Call{BitLength}{\colort}$
        \State $\texttt{uint} ~ ~ \colortau \gets  \Call{BitLength}{\colort} - \Call{I}{\epsilon_{\colortau}}$ \textcolor{teal}{\small//Current meta-epoch}
        \State $\texttt{uint} ~ ~ \colort_0 \gets 2^{\colortau} - \colortau$ \textcolor{teal}{\small//First epoch of meta-epoch}
        \State $\texttt{uint} ~ ~ \colort_1 \gets 2^{\colortau + 1} - (\colortau + 1)$ \textcolor{teal}{\small//First epoch of next meta-epoch}
        \State $\texttt{uint} ~ ~ \epsilon_B \gets \Call{I}{\colort \;\; < \;\; \colorh + \colort_0 \;\; < \;\; \colort_1}$ \textcolor{teal}{\small//Uninvaded correction factor}
        \State $\texttt{uint} ~ ~ B \gets \max(1,\;\; \Call{RightShift}{\colorS, \;\; \colortau + 1 - \epsilon_B})$ \textcolor{teal}{\small//Num bunches}
        \Statex \hspace{2.2in} \textcolor{teal}{\small//avail to \hv}
        \State $\texttt{uint} ~ ~ b_l \gets \Call{ModPow2}{i, \;\; B}$ \textcolor{teal}{\small//Logical (i.e., fill order) bunch index}
        \State $\texttt{uint} ~ ~ v \gets \Call{BitLength}{b_l}$ \textcolor{teal}{\small//Bunch nestedness level}
        \State $\texttt{uint} ~ ~ w \gets \Call{RightShift}{\colorS, \;\; v} \;\; \times \;\;\Call{I}{v > 0}$ \textcolor{teal}{\small//Nest level density}
        \State $\texttt{uint} ~ ~ o \gets 2w$  \textcolor{teal}{\small//Offset of nest level in left-to-right bunch order}
        \State $\texttt{uint} ~ ~ p \gets b_l - \Call{BitFloorSafe}{b_l}$ \textcolor{teal}{\small//Bunch position in nest level}
        \State $\texttt{uint} ~ ~ b_p \gets o + wp$ \textcolor{teal}{\small//Left-to-right bunch index}
        \State $\texttt{uint} ~ ~ \epsilon_{\colork_b} \gets \Call{I}{b_l > 0}$  \textcolor{teal}{\small//Correction factor for 0\textsuperscript{th} bunch}
        \State $\texttt{uint} ~ ~ \colork_b \gets \Call{BitCount}{2b_p +(2\colorS - b_p)} - 1 - \epsilon_{\colork_b}$  \textcolor{teal}{\small//Bunch buff idx}
        \State \Return $\colork_b + \colorh$ \textcolor{teal}{\small//Selected buffer site (\hv{} $\colorh$ gives offset in bunch)}
    \end{algorithmic}
\end{minipage}
\end{algorithm}
