\section{Stretched Algorithm} \label{sec:stretched}

The stretched criterion favors early data items, enjoining a record spaced proportionally to data item ingest time $\colorTbar$.
The criterion can be formulated as minimization of the largest ratio of gap size to ingest time,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar} \text{ for } \colorTbar > 0.
\end{align*}
For buffer size $\colorS$ and time elapsed $\colorT$, ideal retention would space retained items geometrically by ratio $\colorT^{1/\colorS}$.
Counting from zero, under such a layout the $n$th retained data item would have ingestion time $\colorT^{n/(\colorS - 1)}$.
Neglecting discretization effects, gap size ratio can be minimized at best approximately
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
&\stackrel{\sim}{\geq}
\colorT^{1/\colorS} - 1.
\end{align*}

Accounting for discretization provides a strict lower bound on gap size ratio, presented next.

\input{thm/stretched-ideal-strict}

Next, we propose a stream curation algorithm tailored to the stretched criterion, achieving maximum gap size no worse than,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
&\leq
\min\Big(
  \frac{2(\colort + \colors)}{\colorS},
  \frac{4\colort}{\colorS}
\Big).
\end{align*}

Unlike the steady algorithm presented in Section \ref{sec:steady}, which supports indefinitely many data ingestions $\colorT$, our proposed stretched algorithm defines ingest site selection only up to $2^{\colorS}$ data items.
Extension of the stretched algorithm for epoch $\colort > \colorS - \colors$ remains to future work.

\subsection{Stretched Algorithm Strategy}
\label{sec:stretched-strategy}

\input{fig/hsurf-stretched-intuition.tex}

As with the steady algorithm, abstracting data items $\colorTbar$ according to their hanoi value $\colorH(\colorTbar)$ provides the backbone of our approach to stretched curation.
However, instead of keeping just the $n$ highest encountered h.v.'s, to achieve a stretched distribution we instead keep the first $n$ instances of all encountered h.v.'s.
Figure \ref{fig:hanoi-intuition-stretched} shows how keeping the first $n$ instances of each h.v. approximates stretched distribution.

To respect fixed buffer capacity, per-h.v. capacity $n$ must degrade as we encounter new h.v.'s.
Take $\{ \colorTbar \in 0, 1, \, \ldots, \min(\colorT, 2^{\colorh + 1}n - 1) : \colorH(\colorTbar) = \colorh \}$ as denoting the first $n$ encountered instances $\colorTbar$ of hanoi value $\colorh$.
We thus define our algorithmic goal as maintaining --- for a declining threshold $n(\colorT)$ --- the set of data items,
\begin{align*}
\textsf{goal\_stretched}
&=
\bigcup_{\colorh \geq 0}
\{ \colorTbar \in 0, 1, \, \ldots, \min(\colorT, 2^{\colorh + 1}n(\colorT) - 1) : \colorH(\colorTbar) = \colorh \}.
% \quad
% \forall \colorh \in \{ \colorH(\colorTbar) \forall \colorTbar \leq \colorT \}
\end{align*}
By construction, $\textsf{goal\_stretched} \subset \{ \colorTbar \in 0, 1, \, \ldots, \colorT \}$.

We next show setting $n(\colorT) = 2^{\colors - 1 - \colortau}$ suffices to respect available buffer capacity $\colorS$.

\input{thm/stretched-first-n-space.tex}


% Note that, by the nature of the hanoi sequence, the distinct h.v.'s encountered by time $\colorTbar$, $\{ \colorH(\colorTbar) \forall \colorTbar \leq \colorT \}$, , equals $\{0, 1, \,\ldots \left\lfloor \log_2\colorT + 1 \right\rfloor \}$.

\subsection{Stretched Algorithm Mechanism}
\label{sec:stretched-mechanism}

\input{fig/hsurf-stretched-implementation.tex}

Be reminded that our stretched retention goal is to guarantee space for the first $n(\colorT) =  2^{\colors - 1 - \colortau}$ instances of each hanoi value.
A naive mechanism might reserve a full $n(\colorT)$ sites for all $2^{\colors + \colort}$ h.v.'s $\colorh$ encountered through epoch $\colort$, $\colorT \in \colort$.
However, this approach would exceed available buffer capacity.
For example, at $\colortau=\colort=0$,
\begin{align*}
2^{\colors - 1 - \colortau} \times 2^{\colors + \colort}
&=
2^{2\colors - 1}\\
&=
\frac{\colorS^{2}}{2}\\
&\stackrel{\checkmark}{\cancel{\leq}} \colorS \text{ for } \colorS > 1.
\end{align*}

\subsubsection{Stretched Algorithm Layout at $\colort,\colortau=0$}

In motivating a more apt strategy, begin by restricting focus to epoch $\colort=\colortau=0$.
Assume that we reserve sites by h.v. $\colorH(\colorTbar)$, and provide capacity for all data items $0\leq \colorTbar < \colorS$.
Suppose organization of reserved sites into segments, each with at most one site reserved per hanoi value.

Under this scheme, we will have at least $\colorS/2$ segments, one per h.v. $\colorh=0$ instance encountered.
In constructing segments, half of these $\colorh=0$ segments can be augmented with one of the $\colorS/4$ h.v. $\colorh=1$ reservations.
We can continue, and further augment $\colorS/8$ segments with h.v. $\colorh=2$, etc.
Placing all encountered h.v. $\colorh\leq\colors$ yields segment sizes that turn out to recapitulate the hanoi sequence.
Special-casing the largest segment, constructed segment sizes can be enumerated as
\begin{align}
\colors + 1, \colorH(0) + 1, \colorH(1) + 1, \ldots, \colorH(\colorS/2 - 2) + 1.
\label{eqn:stretched-segment-sizes}
\end{align}
These segment sizes can be shown to exactly fill available buffer space $\colorS$,
\begin{align*}
\colors + 1
+  \sum_{\colorh = 0}^{\colors - 2}
2^{\colors - 2 - \colorh} \times (\colorh + 1)
&=
\colors + 1 +
2^{\colors} - \colors - 1\\
&\stackrel{\checkmark}{=}
\colorS.
\end{align*}

Thus far, we have only considered segment sizes --- and not discussed arrangement of segment order onto physical buffer space $\colorS$.
One naive approach would lay segments in descending order by length, as for steady retention in Section \ref{sec:steady}.
However, keeping the hanoi sequence's innate recursive nesting will turn out to serve our objectives.
The bottom row (``epoch 0'') of Figure \ref{fig:hsurf-stretched-intuition-reservations} shows application of this layout strategy to a 32-site buffer, where segment ordering matches that of Formula \ref{eqn:stretched-segment-sizes}.

\subsubsection{Stretched Algorithm Layout at $\colort,\colortau\geq1$}

What about $\colorT \geq \colorS$ (i.e., $\colort \geq 1$)?
At epoch $\colort=\colortau=0$, we have successfully guaranteed $n(\colorT) = 2^{\colors - 1 - \colortau} = \colorS / 2$ reserved sites per hanoi value.
To satisfy $\textsf{stretched\_goal}$ at $\colort=\colortau=1$, we only need to guarantee $n(\colorT) = \colorS/4$ reserved sites --- half as many as at $\colort=\colortau=0$.
So, half of our $S/2$ sites that are reserved to h.v. $\colorh=0$ may be reallocated.
One way to do this is by freeing up the singleton segments containing just h.v. $\colorh=0$.

Subsumption of these eliminated singleton segments makes space for all remaining segments to ``invade'' by extending one site.
Sticking with our convention of at most one site with each h.v. $\colorh$ per reservation segment, invading segments accrue space to host an additional high hanoi value data item.
For instance, the largest segment will grow a site reserved to h.v. $\colorh=\colors +1$.
Two reservation sites will be added for h.v. $\colorh=\colors - 1$, four for h.v. $\colorh=\colors - 2$, etc. --- mirroring the incidence counts for these h.v.'s during epoch $\colort=1$.

In subsequent epochs $\colort>1$, we can continue dissolving the smallest, innermost-nested reservation segments to grow capacity for new high-h.v. data items.
Figure \ref{fig:hsurf-stretched-intuition-reservations} shows several steps through this process on a 32-site buffer.
At final epoch $\colort=\colorS-\colors$ (i.e., $\colorT \approx 2^{\colorS}$), the proposed process of progressive, nested segment subsumption culminates to a single reservation segment containing the first instance of all h.v.'s $0 \leq \colorh < \colorS$.

We will next show that the cadence of meta-epochs $\colortau$ corresponds to the timing of successive segment invasions.

\input{thm/stretched-meta-epoch.tex}
\input{thm/stretched-discarded-incidence-count.tex}
\input{thm/stretched-reservation-count}

\subsubsection{Stretched Algorithm Implementation}
\label{sec:stretched-implementation}

Having determined reservation segment layout strategy, remaining details of site selection can be addressed succinctly.
As we encounter data items $\colorH(\colorTbar) = \colorh$, we fill reserved sites for that h.v. in descending order of initialized segment size $r$.
Within same-segment-size classes, we can simply fill from left to right.
As invasion eliminates smallest initialized segments first, this approach guarantees retention of oldest data items $\colorH(\colorTbar) = \colorh$.
Once sites reserved to h.v. $\colorh$ fill, further instances $\colorH(\colorTbar) = \colorh$ are discarded without storage.
Figure \ref{fig:hsurf-stretched-implementation-schematic} illustrates site selection over epochs $\colort=0,1,2$ on buffer size $\colorS=32$.

Ingestion time calculation for lookup of the data item at buffer site $\colork$ at time $\colorT$ can be accomplished by decoding that site's segment index and checking whether (if slated) it has yet been replaced during the current epoch $\colort$.
Both site selection and ingest time calculation can be accomplished through fast $\mathcal{O}(1)$ binary operations (e.g., bit mask, bit shift, count leading zeros).
We refer the reader to our supplemental Python-language implementation for an exact step-by-step listing of both operations for the stretched algorithm.

\subsection{Stretched Algorithm Criterion Satisfaction}
\label{sec:stretched-satisfaction}

In this final subsection, we establish an upper bound on gap size ratio $\colorg / \colorTbar$ for a buffer of size $\colorS$ at time $\colorT$ under the proposed stretched curation algorithm.

\input{thm/stretched-gap-size}

Consideration of the gap size bound result found in Theorem \ref{thm:stretched-gap-size} at small and large $\colort$ is instructive.
During the first epoch where $\colort = 1$,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
\leq
\frac{4}{\colorS}.
\end{align*}

Likewise, during the last supported epoch, where $\colort = \colorS - \colors$,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
\leq
2.
\end{align*}

Considering $\colort = \colorS - \colors$, as a special case, however, we can establish a tighter bound of 1.

\begin{lemma}[Worst-case Gap Size Ratio in Final Epoch]
For $\colorT \in (\colort = \colorS - \colors)$,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
&\leq
1.
\end{align*}
\end{lemma}
\begin{proof}
By construction, $(\colorTbar=0) \in \colorB_{\colorT}$.

Suppose $\exists 2^{\colorS - 1} \leq \colorT < 2^{\colorS}, \colorTbar > 0$ such that $\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar} > 1$.
Then, $\exists \colorTbar$ such that $\{\colorTbar,\colorTbar+1,\,\ldots,2\times\colorTbar \} \in \colorBnot_{\colorT}$.
Because $\exists 0 \leq n < \colorS$ such that $2^n - 1 \in \{\colorTbar,\colorTbar,\,\ldots,2\times\colorTbar\}$, this would imply $
\exists 2^n - 1 \in \colorBnot_{\colorT}$.
However, segment layout provides reserved sites for all h.v. $0\leq\colorh<\colorS$ in final epoch $\colort = \colorS - \colors$, so $\nexists \colorT,\colorTbar$ violating the bound.
\end{proof}

Figure \ref{fig:hsurf-stretched-implementation-satisfaction} shows algorithm performance on the stretched criterion for buffer size $\colorS=16$, $0 \leq \colorT < 2^{\colorS}$.

%The largest h.v. encountered is $\colorH(\colorS/4 - 1) = \left\lfloor \log_2(\colorS/4) \right\rfloor = \colors - 2$.
