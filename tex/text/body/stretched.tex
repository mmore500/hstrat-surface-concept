\section{Stretched Algorithm} \label{sec:stretched}

The stretched criterion favors recent data items, enjoining a record spaced proportionally to data item ingest time $\colorTbar$.
The criterion can be formulated as minimization of the largest ratio of gap size to ingest time,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar} \text{ for } \colorTbar > 0.
\end{align*}
For buffer size $\colorS$ and time elapsed $\colorT$, ideal retention would space retained items geometrically by ratio $\colorT^{1/\colorS}$.
Counting from zero, under such a layout the $n$th retained data item would have ingestion time $\colorT^{n/(\colorS - 1)}$.
Neglecting discretization effects, gap size ratio can be minimized at best approximately
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
&\stackrel{\sim}{\geq}
\colorT^{1/\colorS} - 1.
\end{align*}

Accounting for discretization provides a strict lower bound on gap size ratio, presented next.

\input{thm/stretched-ideal-strict}

Next, we propose a stream curation algorithm tailored to the stretched criterion, achieving maximum gap size no worse than,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
&\leq
\min\Big(
  \frac{2(\colort + \colors)}{\colorS},
  \frac{4\colort}{\colorS}
\Big).
\end{align*}

Unlike the steady algorithm presented in Section \ref{sec:steady}, which supports indevinitely many data ingestions $\colorT$, thewe define our proposed stretched algorithm defines ingest site selection only up to $2^{\colorS}$ data items.
Extension of the stretched algorithm for epoch $\colort > \colorS - \colors$ remains to future work.

\subsection{Strategy}

\input{fig/hsurf-stretched-intuition.tex}

As with the steady algorithm, abstracting data items $\colorTbar$ according to their hanoi value $\colorH(\colorTbar)$ provides the backbone of our stretched approach.
However, instead of keeping all instances of the $n$ highest encountered h.v.'s, we instead keep the first $n$ instances of all encountered h.v.'s in order to achieve a stretched distribution.
To accomodate storing instances of new h.v.'s as we first encounter them, $n$ must degrade as time progresses.
Figure \ref{fig:hanoi-intuition-stretched} depicts this core strategy.

Take $\{ \colorTbar \in 0, 1, \, \ldots, \min(\colorT, 2^{\colorh + 1}n - 1) : \colorH(\colorTbar) = \colorh \}$ as denoting the first $n$ encountered instances $\colorTbar$ of hanoi value $\colorh$.
We thus define our algorithmic goal as maintaining --- for a declining threshold $n(\colorT)$ --- the set of data items,
\begin{align*}
\bigcup_{\colorh \geq 0}
\{ \colorTbar \in 0, 1, \, \ldots, \min(\colorT, 2^{\colorh + 1}n(\colorT) - 1) : \colorH(\colorTbar) = \colorh \}.
% \quad
% \forall \colorh \in \{ \colorH(\colorTbar) \forall \colorTbar \leq \colorT \}
\end{align*}
By construction, $\subset \{ \colorTbar \in 0, 1, \, \ldots, \colorT \}$.
Demonstrated next, setting $n(\colorT) = 2^{\colors - 1 - \colortau}$ respects available buffer capacity $\colorS$.

\input{thm/stretched-first-n-space.tex}


% Note that, by the nature of the hanoi sequence, the distinct h.v.'s encountered by time $\colorTbar$, $\{ \colorH(\colorTbar) \forall \colorTbar \leq \colorT \}$, , equals $\{0, 1, \,\ldots \left\lfloor \log_2\colorT + 1 \right\rfloor \}$.

\subsection{Mechanism}

\input{fig/hsurf-stretched-implementation.tex}

Recall that we wish to guarantee space for the first $n(\colorT) =  2^{\colors - 1 - \colortau}$ instances of each hanoi value.
A naive mechanism might reserve a full $n(\colorT)$ sites for all $2^{\colors + \colort}$ encountered through epoch $\colort$, $\colorT \in \colort$.
However, this approach would exceed available buffer capacity.
For example, at $\colortau=\colort=0$,
\begin{align*}
2^{\colors - 1 - \colortau} \times 2^{\colors + \colort}
&=
2^{2\colors - 1}\\
&=
\frac{\colorS^{2}}{2}\\
&\stackrel{\checkmark}{\cancel{\leq}} \colorS \text{ for } \colorS > 1.
\end{align*}

In motivating a more apt strategy, let's begin by restricting our focus to $\colort=\colortau=0$.
Assume that we reserve one site per h.v. instance $\colorH(\colorT)$ encountered for $\colorT < \colorS$.
Further assume organization of reserved sites into segments, with each segment contianing at most one instance of each hanoi value.
We will have at least $S/2$ segments, one per h.v. $\colorh=0$ instance encountered.
Half of these segments could be extended by one site, each accomodating one of the $S/4$ encountered h.v. $\colorh=1$ instances.
Continuing to accomodate all encountered h.v. $\colorh\leq\colors$, segment sizes turn out to recapitulate the hanoi sequence.
Special-casing the largest segment, we can construct our segment collection as sizes
\begin{align*}
\colors + 1, \colorH(0) + 1, \colorH(1) + 1, \ldots, \colorH(\colorS/2 - 2) + 1.
\end{align*}
Note that these segments exactly fill available buffer space $\colorS$,
\begin{align*}
\colors + 1
+  \sum_{\colorh = 0}^{\colors - 2}
2^{\colors - 2 - \colorh} \times (\colorh + 1)
&=
\colors + 1 +
2^{\colors} - \colors - 1\\
&\stackrel{\checkmark}{=}
\colorS.
\end{align*}

Thus far, we have only discussed segment sizes --- and not the order of segment arrangement onto physical buffer space $\colorS$.
One approach might lay segments in descending order by length, as we did for steady retention in Section \ref{sec:steady}.
However, adopting the hanoi sewuence's innate recursively nested ordering will turn out to serve our objectives.
The bottom row (``epoch 0'') of Figure \ref{fig:hsurf-stretched-intuition-reservations} shows application of this layout strategy to a 32-site buffer.

What about $\colorT \geq \colorS$ (i.e., $\colort \geq 1$)?
At epoch $\colort=\colortau=0$, we are successfully guaranteeing $n(\colorT) = 2^{\colors - 1 - \colortau} = \colorS / 2$ reserved sites per h.v.
At $\colort=\colortau=1$, we only need to guarantee $n(\colorT) = \colorS/4$ reserved sites --- half as many.
So, half of our $S/2$ h.v. $\colorh=0$ reserved sites may be reallocated.
We can do this by freeing up the length-one segments containing just h.v. $\colorh=0$.

Under our recursively-nested segment layout, subsumption of these eliminated singleton segments allows all remaining segments to ``invade'' by extendeding one site.
Sticking with our convention of at most one site for each h.v. $\colorh$ per reservation segment, the remaining segments may accrue space for an additional high hanoi value.
For instance, the largest segment will grow a site for h.v. $\colors +1$.
Two reservation sites will be added for h.v. $\colors - 1$, four for h.v., $\colors - 2$, etc. --- mirroring the distribution of new incidence counts for these h.v.'s during epoch $\colort=1$.

In subsequent epochs $\colort>1$, we can continue dissolving the smallest, innermost-nested reservation segments by one site per epoch to add capacity for new high-h.v. data items.
Figure \ref{fig:hsurf-stretched-intuition-reservations} shows several steps through this process on a 32-site buffer.
At final epoch $\colort=\colorS-\colors$ ($\colorT \approx 2^{colorS}$), this progressive nested subsimption culminates to a single reservation segment containing the first instance of all h.v.'s $0 \leq \colorh < \colorS$.

\input{thm/stretched-meta-epoch.tex}

\subsection{Criterion Satisfaction}

In this final subsection, we establish an upper bound on gap size $\colorg$ for a buffer of size $\colorS$ at time $\colorT$ under the proposed stretched curation algorithm.

\input{thm/stretched-reservation-count}

\input{thm/stretched-gap-size}

Consideration of the gap size bound result found in Theorem \ref{thm:stretched-gap-size} at small and large $\colort$ is instructive.
During the first epoch where $\colort = 1$,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
\leq
\frac{4}{\colorS}.
\end{align*}

Likewise, during the last supported epoch, where $\colort = \colorS - \colors$,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
\leq
2.
\end{align*}

However, we can use the exact expression (rather than a bound) to establish a tighter bound at $\colort = \colorS - \colors$, where $\colortau = \colors$,
\begin{align*}
\frac{\colorG_{\colorT}(\colorTbar)}{\colorTbar}
\leq
2^{\colors - 1 - \colortau}\\
&\leq
2^{- 1}. TODO FIXME should be 1 not 1/2
\end{align*}
