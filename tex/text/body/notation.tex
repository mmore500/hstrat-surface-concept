\section{Preliminaries, Notations, and Terminology} \label{sec:notation}

The core function of proposed algorithms is curating incoming data on a rolling basis to dynamically retain a subset that, according to a desired \textbf{coverage criterion}, provides sufficient coverage over observed history.
We consider the one-dimensional sequence of \textbf{data items} $v_i$ as a \textbf{data stream}.
We refer to the act of reading an item from the data stream as \textbf{ingesting} it.
For the purposes of present discussion, we assume data items to be fixed-size (i.e., fitting within an allocated buffer space) and do not consider the actual values of the data items further.

We will notate the \textit{number of available buffer sites} as $\colorS$.
In their current form, proposed algorithms assume fixed-size buffer space, sufficient to store $\colorS$ data items.%
\footnote{%
In associated materials, the fixed-size buffer used to store curated data items is referred to as a ``surface.''%
}
They require buffer size to be an even power of two, so that for some $\colors$, $\colorS = 2^{\colors}$.
On occasion it will become necessary to refer to a specific position $k$ within a buffer.
We will take a zero-indexing convention so $0 \leq \colork < \colorS$.

We consider only one operation on the buffer: storage of an ingested data item.
Placing a data item from the data stream onto an already-occupied buffer site overwrites it.
To maintain simplicity, algorithms do not move, swap, or read already-stored data.
Further, we store only the data items themselves in buffer space --- no metadata (e.g., ingestion time) or data structure components (e.g., indices or pointers) are stored.

We will refer to each \textit{data item's stream sequence index} as its time $\colorT$.
In referring to time, we will also take a zero-indexing convention, describing that the first element of the data stream associates to time $\colorT=0$.
We assume $\colorT$ to be known exactly, which is simple to accomplish by in practice by maintaining a counter that increments each time a data item is ingested.
Note that \textit{coverage criteria} considered here are defined solely in terms of time indices $\colorT$ of retained data items --- not their data values.
We define coverage criteria in terms of \textbf{gap size} between retained data items, defined as the number of contiguously sequential data items discarded (i.e., overwritten).

Algorithms for two coverage criteria are treated: \textbf{steady} and \textbf{tilted} in Sections \ref{sec:steady} and \ref{sec:tilted}, respectively.
The \textit{steady criterion} seeks to maintain data items with time indices that evenly cover elapsed history.
The \textit{tilted criterion} also seeks to maintain data items with time indices spread across elapsed history, but with recency-proportional density such that more more-recent data items are maintained.
Formal definition of each criterion is provided in its corresponding section.

It happens that for the structure of the algorithms, the binary order of magnitude of the time $\colorT$ plays an important structural role.
We will refer to this value $\colort$ as the \textbf{epoch} of $\colorT$.
We associate time $\colorT=0$ to epoch $\colort=0$ and treat $\colorT < \colorS$ --- before the buffer fills --- as epoch 0.

For the \textit{steady algorithm}, epoch transition occurs immediately before a new binary order of magnitude (e.g., between $\colorT = 15$ and $\colorT = 16$ or between $\colorT = 31$ and $\colorT = 32$), so $\colort = \left\lfloor \log_2(\colorT) \right\rfloor - \colors + 1$ for $\colorT \geq \colorS$.
For the \textit{tilted algorithm}, epoch transition occurs immediately \textit{after} a new binary order of magnitude (e.g., between $\colorT = 16$ and $\colorT = 17$).
So, in this context $\colort = \left\lfloor \log_2(\colorT - 1) \right\rfloor - \colors + 1$ for $\colorT > \colorS$.

\input{fig/hanoi-intuition.tex}

It also happens that for the structure of the algorithms, time values' associated entry in the binary carry sequence is also frequently relevant.
The first few terms of this sequence are $0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, \ldots$ \, .
This sequence appears as A007814 in the On-Line Encyclopedia of Integer Sequences \citep{oeis}.
We adopt a zero-indexing convention, so $\colorH(0) = 0$, $\colorH(1) = 1$, $\colorH(2) = 0$, etc.

For each time point $\colorT$ we refer to its corresponding entry in the binary carry sequence $\colorH(\colorT) = \colorh$ as its ``\textbf{hanoi value},'' in reference to the famous ``tower of hanoi'' puzzle \citep{lucas1889jeux}.
On occasion, we abbreviate this term as ``h.v.''
Some intuition for the structure of this sequence is requisite to later discussions.
Note that element 0 appears every 2nd entry, element 1 appears every 4th entry, and in the general case element $\colorh$ appears every $2^{\colorh+1}$th entry.
Finally, it is worth remarking that when hanoi value $\colorh$ appears for the first time, the value $\colorh - 1$ has appeared exactly once.
So, we have seen exactly one instance of $\colorh$ and also exactly one instance of $\colorh - 1$.
At this point, the value $\colorh - 2$ has appeared exactly twice, and in general the value $\colorh - n$ has appeared $2^{n - 1}$ times.

As a final piece of minutiae, let binary floor of a value $x$ be denoted $\left\lfloor x \right\rfloor_\mathrm{bin} = \exp(2, \left\lfloor \log_2 x \right\rfloor)$.
