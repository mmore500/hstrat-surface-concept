\section{Experimental Evaluation}
\label{sec:performance}

To better understand the runtime performance characteristics of the generalized ring buffer approach, we undertook on-hardware benchmark tests to compare trade-offs in memory usage and stream processing speed against alternate approaches.
In addition to the proposed DStream tilted algorithm, our tests also considered Gunther's compressing circular buffer algorithm as, to our knowledge, its performance has only been reported a desktop computing context \citep{gunther2014compressing}.

Given the focus of this work in supporting data stream management resource-constrained computing scenarios, we targeted our benchmarks to the Raspberry Pi Pico RP2040 --- a popular ARM-based microcontroller platform \citep{raspberrypipico2024}.
Due to fundamental tradeoffs processor architecture related to manufacturing cost and energy intensivity, embedded devices exhibit a substantially differentiated performance profile compared to mainline desktop CPU processors \citep{schlett2000embedded}.
Notably, embedded microprocessors typically offer more limited faculties for pipelining, vector operations, and specialized instruction logic  \citep{yiu2015definitive}
Indeed, some similarities exist in this regard between embeddeded processors and emerging AI/ML hardware accelerator platforms' worker compute cores in terms of in the reduced instruction set size and low relative latency for local memory access --- although the latter much more heavily emphasizes instruction-level parallelism (i.e., vectorized operations)
\citep{lie2023cerebras} \citep{vasiljevic2021compute}.

In our benchmark trials, we measured time elapsed to ingest 10,000, 100,000, and 1,000,000 items from a data stream.
As a simple stand-in for otherwise domain-specific use cases, the underlying data stream in our experiments comprised a deterministic sequence generated by 32-bit xorshift PRNG, where each element is related to the prior by three shift/xor operations \citep{marsaglia2003xorshift}.
Being nontrivial, this stream model ensured performance of a verifiable computation, while remaining straightforward, lightweight, and reproducible.
Across trials, we tested algorithm behavior for handling single-bit, single-byte, word, and double-word data items drawn from the xorwow stream.
In addition to algorithm run time, our benchmarks also measured memory use to store sampled data items.

\subsection{Compared Approaches and Control Treatments}

\input{tab/algorithms.tex}

In this section, we report on-hardware benchmark experiments to compare the runtime behavior of DStream curation against current practice --- namely, the equi-segmented algorithm within the generalized time series dimension-reduction framework proposed by \citet{zhao2005generalized}.

\subsection{Methodology}
\label{sec:materials}

Benchmark code was implemented in C++.
We also used compile-time means to record exact measurents of memory use.

Memory usage was calculated at compile-time using the \texttt{sizeof} builtin.
For the doubling algorithms, which fluctuate between utilizing half of buffer space and full buffer space, we assumed a mean load factor of 0.75.

Experiments were performed on a Raspberry Pi Pico RP2040 Microcontroller Board, which features a Dual-Core ARM Cortex-M0+ chip clocked at 133 MHz.
The RP2040 provides 264KB of SRAM and 2MB of on-board flash memory.
Embedded experiments were compiled with the Raspberry Pi Pico SDK version 2.1.0, which bundles ARM GNU Toolchain 13.3.1 \citep{raspberrypipico2024}.
Ten replicates were taken for each embedded timing.

Across all trials, executables were compiled with optimization level \texttt{O3} with native micro-architecture and, for HPC experiments, ISA extensions enabled.
Appropriate steps were taken to prevent the operations interest from being inadvertently optimized away.
To accurately reflect scenarios where stream length is unknown \textit{a priori}, we took steps to ensure total loop count was unknown as compile time.
Benchmarking code and results are publicly available, as described in Section \ref{sec:materials}.

\subsection{Software and Data Availability}
\label{sec:materials}

Supporting software and executable notebooks for this work are available via Zenodo at \url{https://doi.org/10.5281/zenodo.10779240} \citep{moreno2024hsurf}.
DStream algorithm implementations are also published on PyPI in the \texttt{downstream} Python package and at \url{https://github.com/mmore500/downstream}, where we plan to conduct longer-term, end-user-facing development and maintenance \citep{moreno2024downstream}.
Supplemental materials are available via the Open Science Framework at \url{https://osf.io/na2wp} and \url{https://osf.io/kjpqu/} \citep{foster2017open}.
All accompanying software and materials are provided open-source under the MIT License.

This project benefited significantly from open-source scientific software \citep{2020SciPy-NMeth,harris2020array,reback2020pandas,mckinney-proc-scipy-2010,waskom2021seaborn,hunter2007matplotlib,moreno2023teeplot}.


\subsection{Time Benchmark Results}

\input{fig/pico-performance}

\subsection{Memory Benchmark Results}

\input{fig/steady-mem}
\input{fig/tilted-mem}

\subsection{Solution Quality Results}

\input{fig/steady-qos}
\input{fig/tilted-qos}

Figure \ref{fig:tilted-qos} shows solution quality, as measured by the growth in largest gap size between retained elements ratio TODO.
% Recall that an optimal solution will keep minimize this value by evenly spacing elements across history.
