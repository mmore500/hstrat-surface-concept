\section{Experimental Evaluation}
\label{sec:performance}

% \input{fig/perf}

% \input{tab/perf}
% \input{tab/perf-embedded}

Given the application-oriented posture of this work, we extended our analysis to assess the practical impact of DStream curation on memory efficiency and stream processing throughput.
In this section, we report on-hardware benchmark experiments to compare the runtime behavior of DStream curation against current practice --- namely, the equi-segmented algorithm within the generalized time series dimension-reduction framework proposed by \citet{zhao2005generalized}.

A notable aspect of the work is in creating a representative picture including resource-constrained computing contexts, where order-of-magnitude memory savings enabled to are particularly impactful, we supplemented trials in a traditional CPU-oriented High-Performance Computing (HPC) environment with an additional set of trials targeting embedded computing microprocessor hardware.
As described earlier, the motivating application in hereditary stratigraphy in developing this work is a synthesis of the two: HPC simulation code harnessing embedded-like peripheral processing engines, ranging from established GPU hardware to emerging AI/ML accelerator platforms such as the Cerebras Wafer-Scale Engine.

A core objective of our algorithm is to generalize across data stream applications.
For this reason, we used an artificial stand-in data stream to ensure our experiments were straightforward and reproducible, but nontrivial.
For these purposes, we used a deterministic sequence generated by 32-bit xorshift PRNG, where each element is related to the prior by three shift/xor operations \citep{marsaglia2003xorshift}.

\subsection{Benchmark Methodology}

Benchmark code was implemented in C++.
We implemented the naive algorithm baseline using the memory-compact \texttt{std::vector<bool>} specialization.
We also used compile-time means to record exact measurents of memory use.

Memory usage was calculated at compile-time using the \texttt{sizeof} builtin.

Experiments were performed on a Raspberry Pi Pico RP2040 Microcontroller Board, which features a Dual-Core ARM Cortex-M0+ chip clocked at 133 MHz.
The RP2040 provides 264KB of SRAM and 2MB of on-board flash memory.
Embedded experiments were compiled with the Raspberry Pi Pico SDK version 2.1.0, which bundles ARM GNU Toolchain 13.3.1 \citep{raspberrypipico2024}.
Ten replicates were taken for each embedded timing.

Across all trials, executables were compiled with optimization level \texttt{O3} with native micro-architecture and, for HPC experiments, ISA extensions enabled.
Appropriate steps were taken to prevent the operations interest from being inadvertently optimized away.
To accurately reflect scenarios where stream length is unknown \textit{a priori}, we took steps to ensure total loop count was unknown as compile time.
Benchmarking code and results are publicly available, as described in Section \ref{sec:materials}.

\subsection{Software and Data Availability}
\label{sec:materials}

Supporting software and executable notebooks for this work are available via Zenodo at \url{https://doi.org/10.5281/zenodo.10779240} \citep{moreno2024hsurf}.
DStream algorithm implementations are also published on PyPI in the \texttt{downstream} Python package and at \url{https://github.com/mmore500/downstream}, where we plan to conduct longer-term, end-user-facing development and maintenance \citep{moreno2024downstream}.
Supplemental materials are available via the Open Science Framework at \url{https://osf.io/na2wp} and \url{https://osf.io/kjpqu/} \citep{foster2017open}.
All accompanying software and materials are provided open-source under the MIT License.

This project benefited significantly from open-source scientific software \citep{2020SciPy-NMeth,harris2020array,reback2020pandas,mckinney-proc-scipy-2010,waskom2021seaborn,hunter2007matplotlib,moreno2023teeplot}.


\subsection{Time Benchmark Results}

\input{fig/pico-performance}

\subsection{Memory Benchmark Results}

\input{fig/steady-mem}
\input{fig/tilted-mem}

\subsection{Solution Quality Results}

\input{fig/steady-qos}
\input{fig/tilted-qos}

Figure \ref{fig:tilted-qos} shows solution quality, as measured by the growth in largest gap size between retained elements ratio TODO.
% Recall that an optimal solution will keep minimize this value by evenly spacing elements across history.
