\section{Steady Algorithm} \label{sec:steady}

The steady criterion seeks to retain data items from time points evenly spread across observed history.
The criterion can be formulated as minimization of the largest gap size between retained data items.
For a buffer size $\colorS$ and time elapsed $\colorT$, maximum gap size can be bounded at best $\left\lceil \colorT / \colorS \right\rceil$.
This section presents a stream curation algorithm designed to support the steady criterion, achieving maximum gap size no worse than $2\left\lceil \colorT / \colorS \right\rceil$.

\subsection{Strategy}

Figure \ref{fig:hanoi-intuition-steady} shows the proposed algorithm's core strategy, which revolves around placing and retaining data items according to the hanoi value of their sequence index $\colorH(\colorTbar)$.
Keeping data items with hanoi value $\colorh > n$ produces gap sizes at most $\colorg \leq 2^n - 1$.
For intuition, imagine discarding items with $\colorH(\colorTbar) = 0$.
This drops every other item, and results in gap size to $\colorg \leq 1$.
Imagine subsequently removing items with $\colorH(\colorTbar) = 1$.
This again drops every other item, and increases gap size to $\colorg \leq 3$.
Pruning according to hanoi value thus provides a well-behaved transition to gracefully increase gap size while keeping even spacing.

Our goal is thus to maintain all items $\colorTbar_y$ with hanoi value $\colorH(\colorTbar_y)$ above some threshold $n(\colorT)$ by repeatedly discarding items $\colorTbar_x$ with lowest hanoi value $\colorH(\colorTbar_x) = n(\colorT)$.
To fill available buffer space $\colorS$, it turns out that, at each epoch $\colort$, we should keep all items with all items $\colorTbar$ with h.v. equal to or greater than the current epoch, $\colorH(\colorT) \geq \colort$.

\begin{lemma}[Data items with h.v. greater than or equal to current epoch.]
At any time $\colorT$ in epoch $\colort$, sufficient buffer space exists to store all data items with h.v. $\colorh \geq \colort$.
That is, $\left| \{\colorTbar \in \{0, \ldots, \colorT \} \ni \colorH(\colorTbar) \geq \colort \} \right| \leq \colorS$.
\end{lemma}

\begin{proof}
Because counts of encountered h.v.'s increase with time, it is sufficient to consider just $\max\{\colorT \in \colort\} = 2^{\colors} - 2$.
Recall that h.v. $\colorh $is encountered for the first time at time $\colorT = 2^{\colorh} - 1$.
So, h.v. $\colorh = \colors + \colort$ is encountered at $\colorT = 2^{\colors + \colort} - 1$.
At that time, there are $\colors$ distinct hanoi values $\colorh$ such that $\colort \leq \colorh \leq \colors + \colort$.
Summing h.v. data item counts and subtracting away $\colorh = \colors + \colort$ (which lies one time point beyond epoch $\colort$) gives
\begin{align*}
\left| \{\colorTbar \in \{0, \ldots, 2^{\colors} - 2 \} \ni \colorH(\colorTbar) \geq \colort \} \right|
&= \left| \{\colorTbar \in \{0, \ldots, 2^{\colors} - 1 \} \ni \colorH(\colorTbar) \geq \colort \} \right| - 1\\
&= 1 + \sum_{i=1}^{\colors} 2^{i - 1} - 1 = 2^{\colors} - 1 = \colorS - 1\\
&\stackrel{\checkmark}{\leq} \colorS.
\end{align*}
\end{proof}

\subsection{Mechanism}

\input{fig/hsurf-steady-intuition}

Maintaining all $\colorTbar$ such that $\colorH(\colorT) \geq \colort$, we have shown, requires nearly all buffer space $\colorS$.
(Although we, in fact, have one extra buffer site left over, in practice it is often useful to use this site to permanently retain the very first or the very most recent data item.)
% Note that, under this scheme, there are never retained items $\colorT$ such that $\colorH(\colorT) < \colort - 1$.
Thus, under our scheme, each epoch, all items with $\colorH(\colorT) = \colort - 1$ must be overwritten to make space for new items with higher hanoi value.

Figure \ref{fig:hsurf-steady-intuition} overviews the layout procedure used to sequence the replacement of data items with h.v. $\colort - 1$ replacement each epoch.
This procedure divides buffer space into ``bunches,'' themselves divided into ``segments.''
Bunch 0 contains 1 segment.
Then, for $n > 0$ bunch $n$ contains $2^{n-1}$ segments.
Although segment count increases across bunch, segment length decreases by 1 each bunch, with segments in the last bunch containing only one site.
With $\colors$ bunches, available buffer space $\colorS$ is nearly filled,
\begin{align*}
\colors + \sum_{i=0}^{\colors-1} (\colors - i - 1) \times 2^{i} = 2^{\colors} - 1 = \colorS - 1.
\end{align*}

If, for a hanoi value $\colorh$, we place one data item instance per segment, this organizational scheme happens to naturally segregate data items with that h.v. by ingestion epoch across bunches.
Bunch zero will contain the first data item with h.v. $\colorh$, which is encountered in epoch $\colorh - \colors + 1$.
Bunch zero contains the data item with that h.v. from epoch $\colorh - colors + 2$, and so forth.
Because only one new h.v. surfaces each epoch, during any one epoch we will be taking data item instances from each of the top $\colors$ h.v.'s into storage.
Note that segment size is arranged so that instances from all $\colors - n$ h.v.'s that have ``made it'' to bunch $n$ can be stored without conflicts.

\input{fig/hsurf-steady-implementation}

The properties of this arrangement become useful in managing the sequential eliminations of data items with h.v. $\colorh$ during epoch $\colort=\colorh + 1$.
We have that h.v. $\colorh + \colors$ will place one data item in bunch 0 during epoch $\colort=\colorh + 1$.
This is the same number of data items left by h.v. $\colorh$ in bunch 0.
The same holds for all bunches, with data items left by h.v. $\colorh$ equivalent in number to those to be placed in bunch $n$ from h.v. $\colorh + \colors - n$ during epoch $\colorh + 1$.

As shown in Figure \ref{fig:hsurf-steady-implementation}, we can take advantage of this one-to-one between incoming data items and data items of h.v. $\colorh=\colort-1$ to choreograph a clean elimination of that h.v. by replacement each epoch.
We refer the reader to our supplemental Python-language implementation for full detail, but essentially we can map incoming data items with h.v. $\colorh \geq \colort$ over items slated for elimination by determining their position within each segment as $\colorh$ modulus segment size.

\begin{lemma}
Placing data items within segments modulo h.v. ensures elimination of h.v. $\colorh = \colort - 1$ from each segment every epoch.
\end{lemma}
\begin{proof}
Recall that h.v. $\colorh = \colort + \colors - n - 1$ is placed in the $n$th bunch during epoch $\colort$.
By construction, segments in the $n$th bunch have $\colors - n$ sites.
We must verify that
\begin{align*}
\colort - 1
&\stackrel{?}{=}
\text{invading h.v.} - \text{segment length}\\
&\stackrel{?}{=}
(\colort + \colors - n - 1) - (\colors - n)
 \\
&\stackrel{\checkmark}{=} \colort - 1.
\end{align*}
\end{proof}

% So, at epoch $\colort$ in reservation $n$ the hanoi value $h(j, r)$ will overwrite hanoi value
% \begin{align*}
% h(j, r) - (s - j) - 1 \\
% &= (r - j) - (s - j) - 1 \\
% &\stackrel{\checkmark}{=} r - s - 1.
% \end{align*}

Likewise, identifying the ingestion time $\colorTbar$ of a data item located in buffer site $\colork$ at time $\colorT$ essentially boils down to decoding its semantic bunch and segment indices, then determining whether (if slated) it has yet been replaced during the current epoch.
With availability of binary operators (e.g., bit mask, bit shift, bitwise logical operators), data item placement can be computed in fast $\mathcal{O}(1)$ and, for a buffer of size $\colorS$, all data item ingestion times can be determined in ideal $\mathcal{O}(\colorS)$ time.

\subsection{Criterion Satisfaction}

In this final subsection, we establish an upper bound on gap size $\colorg$ for a buffer of size $\colorS$ at time $\colorT$ under the proposed steady curation algorithm.

\begin{theorem}[Steady Algorithm Worst-case Gap Size]
\label{thm:steady-gap-size}
Under the steady curation algorithm, no gap size $\colorg$ exceeds $\left\lceil 2 \colorT / \colorS \right\rceil$.
\end{theorem}
\begin{proof}
Recall that the time between instances of a h.v. $\colorh$ is $2^{\colorh + 1}$ data items.
Consider also that the time between a h.v. $\colorh$ and a data item with h.v. $>\colorh$ is is $2^{\colorh}$ data items.

Under the proposed algorithm, we retain all data items for hanoi values $\colorh = \max (\colort - \colors, 0)$ and greater.
So, then retained data items occur at most $2^{\max(\colort - \colors, 0)}$ time steps apart.
This corresponds to gap size at most $2^{\max(\colort - \colors, 0)} - 1$.
Now, we test
\begin{align*}
\left\lceil 2 \colorT / \colorS \right\rceil
&\stackrel{?}{\geq}
2^{\max(\colort - \colors, 0)} - 1\\
&\stackrel{?}{\geq}
\max(2^{\colort} / 2^{\colors}, 1) - 1\\
&\stackrel{?}{\geq}
\max(2^{\colort} / \colorS - 1, 0)\\
&\stackrel{\checkmark}{\geq}
\max(2\colorT / \colorS - 1, 0).
\end{align*}
\end{proof}

% Suppose surface size $S = 2^s$ at rank $R$, with $r = \left\lceil \log_2 R \right\rceil$.
% Note that $2 \times R \leq 2^r$.
% In order for the steady algorithm to work, we need to have all values with hanoi value greater than or equal to
% \begin{align*}
% \max(r - s, 0)
% \end{align*}


% We will have seen 1 of hv $r - 1$, 2 of hv $r - 2$, 4 of hv $r - 4$, and $2 ^ {s - 1}$ of hv $\max(r - s, 0)$.
% In general, we will have seen $\left\lfloor 2 ^ (r - h) \right\rfloor$ instances of hanoi value $h$ by epoch $r$.
% Recall $\sum_{i = 0}^{q} 2^i = 2 ^ {q + 1} - 1$.
% Do we have enough space?
% \begin{align*}
% \sum_{i = 0}^{(r - 1) - \max(r - s, 0)} 2 ^ i \\
% &= \sum_{i = 0}^{\min(r - 1, s - 1)} 2 ^ i \\
% &\leq \sum_{i = 0}^{s - 1} 2 ^ i \\
% &\leq 2^s - 1\\
% &\stackrel{\checkmark}{\leq} 2^s
% \end{align*}

% Need to prove:
% \begin{itemize}
% \item the number of reservation slots in $j$th reservation equals the number of hanoi value instances observed during any window where $r = k$.
% \item note, because we always fill completely we will therefore drop instances of hanoi value $r - s - 1$.
% \item that hanoi value $r - s - 1$ is in the $h \mod n$th slot
% \end{itemize}


% The $j$th reservation has $\max(1, 2^{j - 1})$ slots.
% The number of new observations of hanoi value during epoch $r$ is $h$ is $\# h(r) -  \# h(r - 1)$.
% This is
% \begin{align*}
% \left\lfloor 2 ^ {r - h} \right\rfloor - \left\lfloor 2 ^ {r - h - 1} \right\rfloor \\
% &= \left\lfloor 2 ^{r - (r - j)} \right\rfloor - \left\lfloor 2 ^ {r - (r - j) - 1} \right\rfloor \\
% &= 2^j - \left\lfloor 2 ^ {j - 1} \right\rfloor \\
% &= \min(2^j - 2^{j - 1}, 1) \\
% &= \min(2 \times 2^{j - 1} - 2^{j - 1}, 1) \\
% &\stackrel{\checkmark}{=} \min(2^{j - 1}, 1).
% \end{align*}
